/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    '/projects': {
        /**
         * Get Projects
         * @description Return the ProjectState for all projects in the PROJECTS_DIR directory.
         */
        get: operations['get_projects_projects_get']
    }
    '/active_project': {
        /**
         * Set Active Project
         * @description Set the active project in the backend.
         */
        post: operations['set_active_project_active_project_post']
    }
    '/project': {
        /**
         * Update Project
         * @description Update a project's config.yaml.
         *
         * :param state: the updated project state.
         * :return: the updated project information.
         */
        put: operations['update_project_project_put']
        /**
         * Create Project
         * @description Scaffold a new project in PROJECTS_DIR with a configuration file and some folders.
         *
         * :param configuration: the configuration of the new project to create.
         * :return: the configuration of the new project that was created.
         */
        post: operations['create_project_project_post']
        /**
         * Delete Project
         * @description Delete a project and all of its associated files.
         */
        delete: operations['delete_project_project_delete']
    }
    '/start_recording': {
        /**
         * Start Recording
         * @description Start recording data.
         *
         * I think.
         */
        post: operations['start_recording_start_recording_post']
    }
    '/stop_recording': {
        /**
         * Stop Recording
         * @description Stop recording data.
         *
         * I think.
         */
        post: operations['stop_recording_stop_recording_post']
    }
    '/websocket_types': {
        /**
         * Websocket Types
         * @description Just an endpoint so that the Measurement type will show up in the openapi.json.
         */
        get: operations['websocket_types_websocket_types_get']
    }
    '/data_sources': {
        /**
         * Data Sources
         * @description Get the available data streams and their component fields.
         *
         * In order to accomplish this, I am executing each data stream's callback once, which... I feel
         * like has the potential to be problematic in the future. Perhaps something to revisit.
         */
        get: operations['data_sources_data_sources_get']
    }
    '/start_stream/{stream_name}': {
        /**
         * Start Stream
         * @description Start collecting data from a stream.
         *
         * :param stream_name: the string key associated with the DataStream to start.
         */
        put: operations['start_stream_start_stream__stream_name__put']
    }
    '/stop_stream/{stream_name}': {
        /**
         * Stop Stream
         * @description Stop data collection from a stream.
         *
         * :param stream_name: the string key associated with the DataStream to stop.
         */
        put: operations['stop_stream_stop_stream__stream_name__put']
    }
}

export type webhooks = Record<string, never>

export interface components {
    schemas: {
        /**
         * ComponentConfiguration
         * @description Defines a configuration for a single dashboard component.
         */
        ComponentConfiguration: {
            /** Title */
            title: string
            /** Component */
            component: string
            /** Expanded */
            expanded: boolean
            settings: components['schemas']['ComponentSettings']
        }
        /**
         * ComponentSettings
         * @description Defines generic settings for a single dashboard component.
         */
        ComponentSettings: {
            /** Data Sources */
            data_sources: components['schemas']['MessageConfiguration'][]
        }
        /**
         * FieldConfiguration
         * @description Model to describe a single field in a MessageConfiguration.
         *
         * This is analagous to a single PayloadField in the same way that a MessageConfiguration is
         * analagous to a single Message.
         */
        FieldConfiguration: {
            /** Name */
            name: string
            /** Units */
            units?: string
            /** Enabled */
            enabled: boolean
        }
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components['schemas']['ValidationError'][]
        }
        /**
         * Header
         * @description Model to describe message headers.
         *
         * Message headers contain generic information shared by all websocket messages. Also, importantly
         * the `name` key, which corresponds to the type of payload the message contains.
         */
        Header: {
            /** Name */
            name: string
            /**
             * Timestamp
             * Format: date-time
             */
            timestamp: string
        }
        /**
         * Message
         * @description Model to describe WebSocket messages, which consist of a Header and a Payload.
         *
         * Right now payloads are just a list of measurement values which... hopefully can represent a
         * pretty wide array of messages, but maybe this will change in the future.
         */
        Message: {
            header: components['schemas']['Header']
            /** Payload */
            payload: components['schemas']['PayloadField'][]
        }
        /**
         * MessageConfiguration
         * @description Model to describe the data sources used in a particular component.
         *
         * This is "necessary" since components on the frontend can use certain fields from messages.
         */
        MessageConfiguration: {
            header: components['schemas']['Header']
            /** Payload */
            payload: components['schemas']['FieldConfiguration'][]
        }
        /**
         * PanelConfiguration
         * @description Defines a configuration for a single panel, which contains a list of components.
         */
        PanelConfiguration: {
            /** Title */
            title: string
            /** Components */
            components: components['schemas']['ComponentConfiguration'][]
        }
        /**
         * PayloadField
         * @description Model to describe a single field in a message payload.
         *
         * These will most likely be generated by DataStream callbacks. Message payloads can consist of
         * multiple PayloadFields
         */
        PayloadField: {
            /** Name */
            name: string
            /** Value */
            value: number
            /** Units */
            units?: string
        }
        /**
         * ProjectConfiguration
         * @description Defines a configuration for an entire project layout.
         *
         * Projects are composed of panels, which are in turn composed of components.
         */
        ProjectConfiguration: {
            /** Title */
            title: string
            /** Description */
            description: string
            /** Panels */
            panels: components['schemas']['PanelConfiguration'][]
            /** Vertical */
            vertical: boolean
        }
        /**
         * ProjectMetadata
         * @description Contains relevant information about a project, such as its folder location, that is not managed by the user.
         */
        ProjectMetadata: {
            /** Filepath */
            filepath: string
            /**
             * Last Modified
             * Format: date-time
             */
            last_modified: string
        }
        /**
         * ProjectState
         * @description Defines the state of a project, which is composed of its configuration, and its metadata.
         */
        ProjectState: {
            configuration: components['schemas']['ProjectConfiguration']
            metadata?: components['schemas']['ProjectMetadata']
        }
        /**
         * RecordingRequest
         * @description Request parameters for a new recording.
         */
        RecordingRequest: {
            /** Sources */
            sources: components['schemas']['MessageConfiguration'][]
            /** Interval */
            interval: number
        }
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[]
            /** Message */
            msg: string
            /** Error Type */
            type: string
        }
    }
    responses: never
    parameters: never
    requestBodies: never
    headers: never
    pathItems: never
}

export type external = Record<string, never>

export interface operations {
    /**
     * Get Projects
     * @description Return the ProjectState for all projects in the PROJECTS_DIR directory.
     */
    get_projects_projects_get: {
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': components['schemas']['ProjectState'][]
                }
            }
        }
    }
    /**
     * Set Active Project
     * @description Set the active project in the backend.
     */
    set_active_project_active_project_post: {
        parameters: {
            query: {
                active_project_config: string
            }
        }
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': unknown
                }
            }
            /** @description Validation Error */
            422: {
                content: {
                    'application/json': components['schemas']['HTTPValidationError']
                }
            }
        }
    }
    /**
     * Update Project
     * @description Update a project's config.yaml.
     *
     * :param state: the updated project state.
     * :return: the updated project information.
     */
    update_project_project_put: {
        requestBody: {
            content: {
                'application/json': components['schemas']['ProjectState']
            }
        }
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': components['schemas']['ProjectState']
                }
            }
            /** @description Validation Error */
            422: {
                content: {
                    'application/json': components['schemas']['HTTPValidationError']
                }
            }
        }
    }
    /**
     * Create Project
     * @description Scaffold a new project in PROJECTS_DIR with a configuration file and some folders.
     *
     * :param configuration: the configuration of the new project to create.
     * :return: the configuration of the new project that was created.
     */
    create_project_project_post: {
        requestBody: {
            content: {
                'application/json': components['schemas']['ProjectState']
            }
        }
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': components['schemas']['ProjectState']
                }
            }
            /** @description Validation Error */
            422: {
                content: {
                    'application/json': components['schemas']['HTTPValidationError']
                }
            }
        }
    }
    /**
     * Delete Project
     * @description Delete a project and all of its associated files.
     */
    delete_project_project_delete: {
        requestBody: {
            content: {
                'application/json': components['schemas']['ProjectState']
            }
        }
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': unknown
                }
            }
            /** @description Validation Error */
            422: {
                content: {
                    'application/json': components['schemas']['HTTPValidationError']
                }
            }
        }
    }
    /**
     * Start Recording
     * @description Start recording data.
     *
     * I think.
     */
    start_recording_start_recording_post: {
        requestBody: {
            content: {
                'application/json': components['schemas']['RecordingRequest']
            }
        }
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': unknown
                }
            }
            /** @description Validation Error */
            422: {
                content: {
                    'application/json': components['schemas']['HTTPValidationError']
                }
            }
        }
    }
    /**
     * Stop Recording
     * @description Stop recording data.
     *
     * I think.
     */
    stop_recording_stop_recording_post: {
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': unknown
                }
            }
        }
    }
    /**
     * Websocket Types
     * @description Just an endpoint so that the Measurement type will show up in the openapi.json.
     */
    websocket_types_websocket_types_get: {
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': components['schemas']['Message']
                }
            }
        }
    }
    /**
     * Data Sources
     * @description Get the available data streams and their component fields.
     *
     * In order to accomplish this, I am executing each data stream's callback once, which... I feel
     * like has the potential to be problematic in the future. Perhaps something to revisit.
     */
    data_sources_data_sources_get: {
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': components['schemas']['MessageConfiguration'][]
                }
            }
        }
    }
    /**
     * Start Stream
     * @description Start collecting data from a stream.
     *
     * :param stream_name: the string key associated with the DataStream to start.
     */
    start_stream_start_stream__stream_name__put: {
        parameters: {
            path: {
                stream_name: string
            }
        }
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': unknown
                }
            }
            /** @description Validation Error */
            422: {
                content: {
                    'application/json': components['schemas']['HTTPValidationError']
                }
            }
        }
    }
    /**
     * Stop Stream
     * @description Stop data collection from a stream.
     *
     * :param stream_name: the string key associated with the DataStream to stop.
     */
    stop_stream_stop_stream__stream_name__put: {
        parameters: {
            path: {
                stream_name: string
            }
        }
        responses: {
            /** @description Successful Response */
            200: {
                content: {
                    'application/json': unknown
                }
            }
            /** @description Validation Error */
            422: {
                content: {
                    'application/json': components['schemas']['HTTPValidationError']
                }
            }
        }
    }
}
